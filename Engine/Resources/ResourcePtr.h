#pragma once

class Resource;

// ResourcePtr implements reference counted pointers to shared resources.
template <class T>
class ResourcePtr {
public:
    // Make absolutely sure that only types derived from Resource are pointed to by a ResourcePtr. 
    // Note: the error generated by MSVC won't tell you whicl line of code caused the assert to fail, but
    // it will be written in the output log, in the line after the error.
    static_assert(std::is_base_of<Resource, T>::value, "Type is not derived from Resource");

    // A resource pointer should never be default constructed. It should a always be give a pointer to an object.
    ResourcePtr() = delete;
    // Destroy the pointer, remove a reference form the pointed object.
    ~ResourcePtr();
  
    // Copy constructor, must add a reference to the new resource and remove one from the current one.
    ResourcePtr(const ResourcePtr &presOther);
    // Copy constructor, must add a reference to the new resource and remove one from the current one.
    ResourcePtr(T * const presOther);
    // Assignment operator, same properties as the default constructor.
    const ResourcePtr &operator = (const ResourcePtr &presOther);
    // Assignment operator, same properties as the default constructor.
    const ResourcePtr &operator = (T * const presOther);
    // Don't allow to use a Resoruce to be dereferenced.
    T &operator*() = delete;
    // Referencing operator.
    T *operator->();

private:
    // Actual pointer to the resoruce this class wraps.
    T *presResource = { nullptr };
};

